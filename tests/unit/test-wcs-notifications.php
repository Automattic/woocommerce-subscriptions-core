<?php

use PHPUnit\Framework\TestCase;

class WCS_Subscription_Notification_Test extends WP_UnitTestCase {

	protected $notifications_as_group;

	protected $notification_types;

	protected $offset;
	protected $offset_for_settings;

	public function __construct() {
		parent::__construct();

		$this->init_protected_data();

		$this->offset              = '-3 days';
		$this->offset_for_settings = [
			'number' => '3',
			'unit'   => 'days',
		];
	}

	// Mock functions and helpers.

	/**
	 * Mock function to check if an email was sent
	 *
	 * @return bool
	 */
	protected function was_email_sent() {
		return true;
	}

	public function setUp(): void {
		parent::setUp(); // TODO: Change the autogenerated stub

		// Start with a clean slate. Previous Subscription IDs are reused, so it can be a headache.
		as_unschedule_all_actions( '', '', $this->notifications_as_group );
	}

	protected static function create_free_trial_subscription( $args = [], $requires_manual_renewal = 'false', $is_in_trial_period = true ) {

		if ( $is_in_trial_period ) {
			$start_datetime     = new DateTime();
			$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

			$trial_end_datetime = clone $start_datetime;
			$trial_end_datetime->modify( '+1 month' );
			$trial_end_datetime_str = $trial_end_datetime->format( 'Y-m-d H:i:s' );

			$default_args     = [
				'status'     => 'active',
				'start_date' => $start_datetime_str,
			];
			$additional_dates = [
				'date_created' => $start_datetime_str,
				'last_payment' => $start_datetime_str,
				'trial_end'    => $trial_end_datetime_str,
				'next_payment' => $trial_end_datetime_str,
			];
		} else {
			// Subscription started 40 days ago.
			$start_datetime = new DateTime();
			$start_datetime->modify( '-40 days' );
			$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

			// Free trial was for one month, so subscription is about 10 days after free trial.
			$trial_end_datetime = clone $start_datetime;
			$trial_end_datetime->modify( '+1 month' );
			$trial_end_datetime_str = $trial_end_datetime->format( 'Y-m-d H:i:s' );

			// Next payment is coming up at the end of second month.
			$next_payment_datetime = clone $start_datetime;
			$next_payment_datetime->modify( '+2 months' );
			$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );

			$default_args = [
				'status'       => 'active',
				'start_date'   => $start_datetime_str,
				'date_created' => $start_datetime_str,
			];

			$additional_dates = [
				'last_payment' => $trial_end_datetime_str, // Customer paid after the free trial ended.
				'trial_end'    => $trial_end_datetime_str,
				'next_payment' => $next_payment_datetime_str,
			];
		}

		$subscription_args = array_merge(
			$default_args,
			$args
		);

		$subscription = WCS_Helper_Subscription::create_subscription(
			$subscription_args,
			[
				'requires_manual_renewal' => $requires_manual_renewal,
			]
		);

		$subscription->update_dates(
			$additional_dates
		);

		$subscription->save();

		return $subscription;
	}

	protected static function create_simple_subscription( $requires_manual_renewal = 'false' ) {
		$start_datetime     = new DateTime();
		$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

		$next_payment_datetime = clone $start_datetime;
		$next_payment_datetime->modify( '+1 month' );
		$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );

		$subscription = WCS_Helper_Subscription::create_subscription(
			[
				'status'       => 'active',
				'start_date'   => $start_datetime_str,
				'date_created' => $start_datetime_str,
			],
			[
				'requires_manual_renewal' => $requires_manual_renewal,
			]
		);

		$subscription->update_dates(
			[
				'last_payment' => $start_datetime_str,
				'next_payment' => $next_payment_datetime_str,
			]
		);

		$subscription->save();

		return $subscription;
	}

	protected static function create_expiring_subscription( $args = [] ) {
		$start_datetime     = new DateTime();
		$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

		$end_datetime = clone $start_datetime;
		$end_datetime->modify( '+3 month' );
		$end_datetime_str = $end_datetime->format( 'Y-m-d H:i:s' );

		$next_payment_datetime = clone $start_datetime;
		$next_payment_datetime->modify( '+1 month' );
		$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );

		$subscription = WCS_Helper_Subscription::create_subscription(
			[
				'status'       => 'active',
				'start_date'   => $start_datetime_str,
				'date_created' => $start_datetime_str,
			]
		);
		$subscription->update_dates(
			[
				'last_payment' => $start_datetime_str,
				'next_payment' => $next_payment_datetime_str,
				'end_date'     => $end_datetime_str,
			]
		);

		$subscription->save();

		return $subscription;
	}

	protected static function create_expiring_subscription_with_trial( $args = [], $is_in_trial_period = true ) {

		if ( $is_in_trial_period ) {

			$start_datetime     = new DateTime();
			$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

			$end_datetime = clone $start_datetime;
			$end_datetime->modify( '+3 months' );
			$end_datetime_str = $end_datetime->format( 'Y-m-d H:i:s' );

			$next_payment_datetime = clone $start_datetime;
			$next_payment_datetime->modify( '+1 month' );
			$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );

			$default_args = [
				'status'       => 'active',
				'start_date'   => $start_datetime_str,
				'date_created' => $start_datetime_str,
			];

			$additional_dates = [
				'last_payment' => $start_datetime_str,
				'next_payment' => $next_payment_datetime_str,
				'trial_end'    => $next_payment_datetime_str,
				'end_date'     => $end_datetime_str,
			];
		} else {
			$start_datetime = new DateTime();
			$start_datetime->modify( '-40 days' );
			$start_datetime_str = $start_datetime->format( 'Y-m-d H:i:s' );

			// Free trial was for one month, so subscription is about 10 days after free trial.
			$trial_end_datetime = clone $start_datetime;
			$trial_end_datetime->modify( '+1 month' );
			$trial_end_datetime_str = $trial_end_datetime->format( 'Y-m-d H:i:s' );

			$end_datetime = clone $start_datetime;
			$end_datetime->modify( '+3 months' );
			$end_datetime_str = $end_datetime->format( 'Y-m-d H:i:s' );

			$next_payment_datetime = clone $start_datetime;
			$next_payment_datetime->modify( '+2 months' );
			$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );

			$default_args = [
				'status'       => 'active',
				'start_date'   => $start_datetime_str,
				'date_created' => $start_datetime_str,
			];

			$additional_dates = [
				'trial_end'    => $trial_end_datetime_str,
				'last_payment' => $trial_end_datetime_str,
				'next_payment' => $next_payment_datetime_str,
				'end_date'     => $end_datetime_str,
			];
		}

		$subscription_args = array_merge( $default_args, $args );

		$subscription = WCS_Helper_Subscription::create_subscription(
			$subscription_args
		);

		$subscription->update_dates(
			$additional_dates
		);

		$subscription->save();

		return $subscription;
	}

	protected static function disable_notifications_globally() {
		update_option( WC_Subscriptions_Admin::$option_prefix . WC_Subscriptions_Email_Notifications::$switch_setting_string, 'no' );
		delete_option( WC_Subscriptions_Admin::$option_prefix . WC_Subscriptions_Email_Notifications::$offset_setting_string );
	}

	protected function enable_notifications_globally() {
		update_option( WC_Subscriptions_Admin::$option_prefix . WC_Subscriptions_Email_Notifications::$switch_setting_string, 'yes' );
		update_option(
			WC_Subscriptions_Admin::$option_prefix . WC_Subscriptions_Email_Notifications::$offset_setting_string,
			$this->offset_for_settings
		);
	}

	protected function init_protected_data() {
		$reflection    = new ReflectionClass( 'WCS_Action_Scheduler_Customer_Notifications' );
		$as_group_name = $reflection->getProperty( 'notifications_as_group' );
		$as_group_name->setAccessible( true );

		$instance = new WCS_Action_Scheduler_Customer_Notifications();

		// Unhook the hooks from this extra instance that would mess up the tests.
		remove_action( 'woocommerce_before_subscription_object_save', [ $instance, 'update_notifications' ], 10, 2 );
		remove_action( 'woocommerce_subscription_date_updated', array( $instance, 'update_date' ), 10, 3 );
		remove_action( 'woocommerce_subscription_date_deleted', array( $instance, 'delete_date' ), 10, 2 );
		remove_action( 'woocommerce_subscription_status_updated', array( $instance, 'update_status' ), 10, 3 );

		$this->notifications_as_group = $as_group_name->getValue( $instance );

		$notification_types = $reflection->getProperty( 'notification_actions' );
		$notification_types->setAccessible( true );

		$this->notification_types = $notification_types->getValue( $instance );
	}

	// Test cases.

	public function test_notification_not_created_when_disabled() {
		// Globally disabled -> don't create notifications when subscriptions are created.
		self::disable_notifications_globally();

		$actions_before = [];
		foreach ( $this->notification_types as $notification_type ) {
			$actions_before[ $notification_type ] = as_get_scheduled_actions(
				[
					'hook'  => $notification_type,
					'group' => $this->notifications_as_group,
				]
			);
		}

		$subscriptions = [
			$this->create_free_trial_subscription(),
			$this->create_free_trial_subscription( [], 'true' ),
			$this->create_free_trial_subscription( [], 'true', false ),
			$this->create_expiring_subscription(),
			$this->create_expiring_subscription_with_trial(),
			$this->create_simple_subscription(),
			$this->create_simple_subscription( 'true' ),

		];

		$actions_after_create = [];
		foreach ( $this->notification_types as $notification_type ) {
			$actions_after_create[ $notification_type ] = as_get_scheduled_actions(
				[
					'hook'  => $notification_type,
					'group' => $this->notifications_as_group,
				]
			);
		}

		$this->assertEquals( $actions_after_create, $actions_before );

		// Globally disabled -> don't create notifications when subscriptions are updated.
		// Test for status update.
		foreach ( $subscriptions as $subscription ) {
			$subscription->update_status( 'active' ); // this also saves
		}

		// Test for change in next payment date.
		$next_payment_datetime = new DateTime();
		$next_payment_datetime->modify( '+2 months' );
		$next_payment_datetime_str = $next_payment_datetime->format( 'Y-m-d H:i:s' );
		foreach ( $subscriptions as $subscription ) {
			$subscription->update_dates(
				[
					'next_payment' => $next_payment_datetime_str,
				]
			);
			$subscription->save();
		}

		$actions_after_update = [];
		foreach ( $this->notification_types as $notification_type ) {
			$actions_after_update[ $notification_type ] = as_get_scheduled_actions(
				[
					'hook'  => $notification_type,
					'group' => $this->notifications_as_group,
				]
			);
		}

		$this->assertEquals( $actions_after_update, $actions_before );
	}

	public function notification_expectations_data_provider() {
		return [
			'Test 1: Simple subscription with automatic renewal.' =>
				[
					'callback'          => [ self::class, 'create_simple_subscription' ],
					'params'            => [],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_renewal',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 2: Simple subscription with manual renewal.' =>
				[
					'callback'          => [ self::class, 'create_simple_subscription' ],
					'params'            => [ 'true' ],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_renewal',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 3: Free trial with automatic renewal, within trial period.' =>
				[
					'callback'          => [ self::class, 'create_free_trial_subscription' ],
					'params'            => [],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_trial_expiration',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'trial_end' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 4: Free trial with manual renewal, within trial period.' =>
				[
					'callback'          => [ self::class, 'create_free_trial_subscription' ],
					'params'            => [ [], 'true' ],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_trial_expiration',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'trial_end' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 5: Free trial with automatic renewal, after trial period.' =>
				[
					'callback'          => [ self::class, 'create_free_trial_subscription' ],
					'params'            => [ [], 'false', false ],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_renewal',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 6: Free trial with manual renewal, after trial period.' =>
				[
					'callback'          => [ self::class, 'create_free_trial_subscription' ],
					'params'            => [ [], 'true', false ],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly one notification is created.',
							'expected' => 1,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message'  => 'Check that the correct hook is used.',
							'expected' => 'woocommerce_scheduled_subscription_customer_notification_renewal',
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_hook();
							},
						],
						[
							'message'  => 'Check that the correct args are used.',
							'expected' => function ( $subscription, $new_actions ) {
								return WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_args();
							},
						],
						[
							'message'  => 'Check that the notification is in the correct group.',
							'expected' => $this->notifications_as_group,
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_group();
							},
						],
						[
							'message'  => 'Check that the date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_action = array_values( $new_actions )[0][0];

								return $new_action->get_schedule()->get_date();
							},
						],
					],
				],
			'Test 7: Expiring subscription.' =>
				[
					'callback'          => [ self::class, 'create_expiring_subscription' ],
					'params'            => [],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly two notifications are created.',
							'expected' => 2,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message' => 'Check that one expiration and one renewal notifications are created.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$expected_actions = [
									'woocommerce_scheduled_subscription_customer_notification_expiration' => 1,
									'woocommerce_scheduled_subscription_customer_notification_renewal'    => 1,
								];

								$new_actions = array_values( $new_actions )[0];
								foreach ( $new_actions as $new_action ) {
									$hook = $new_action->get_hook();
									if ( isset( $expected_actions[ $hook ] ) ) {
										$expected_actions[ $hook ] --;
									} else {
										return false;
									}
								}

								return array_sum( $expected_actions ) === 0;
							},
						],
						[
							'message' => 'Check that the correct args are used.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									$args          = $new_action->get_args();
									$expected_args = WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );

									if ( $args !== $expected_args ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message' => 'Check that the notifications are in the correct group.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_group() !== $this->notifications_as_group ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message'  => 'Check the subscription expiry notification date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$end_date = new DateTime( $subscription->get_date( 'end_date' ) );
								$end_date->modify( $this->offset );

								return $end_date;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];
								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_expiration' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
						[
							'message'  => 'Check the next payment date notification is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];
								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_renewal' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
					],
				],
			'Test 8: Expiring subscription with trial, within trial.' =>
				[
					'callback'          => [ self::class, 'create_expiring_subscription_with_trial' ],
					'params'            => [],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly two notifications are created.',
							'expected' => 2,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message' => 'Check that one expiration and one trial expiration notifications are created.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$expected_actions = [
									'woocommerce_scheduled_subscription_customer_notification_expiration'       => 1,
									'woocommerce_scheduled_subscription_customer_notification_trial_expiration' => 1,
								];

								$new_actions = array_values( $new_actions )[0];
								foreach ( $new_actions as $new_action ) {
									$hook = $new_action->get_hook();
									if ( isset( $expected_actions[ $hook ] ) ) {
										$expected_actions[ $hook ] --;
									} else {
										return false;
									}
								}

								return array_sum( $expected_actions ) === 0;
							},
						],
						[
							'message' => 'Check that the correct args are used.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									$args          = $new_action->get_args();
									$expected_args = WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );

									if ( $args !== $expected_args ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message' => 'Check that the notifications have the correct group.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_group() !== $this->notifications_as_group ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message'  => 'Check the subscription expiry notification date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$end_date = new DateTime( $subscription->get_date( 'end_date' ) );
								$end_date->modify( $this->offset );

								return $end_date;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_expiration' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
						[
							'message'  => 'Check the trial expiry notification date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_trial_expiration' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
					],
				],

			'Test 9: Expiring subscription with trial after trial.' =>
				[
					'callback'          => [ self::class, 'create_expiring_subscription_with_trial' ],
					'params'            => [ [], false ],
					'assertions_config' => [
						[
							'message'  => 'Check that exactly two notifications are created.',
							'expected' => 2,
							'actual'   => function ( $subscription, $new_actions ) {
								return count( array_values( $new_actions )[0] );
							},
						],
						[
							'message' => 'Check that one expiration and one renewal notifications are created.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$expected_actions = [
									'woocommerce_scheduled_subscription_customer_notification_expiration' => 1,
									'woocommerce_scheduled_subscription_customer_notification_renewal'    => 1,
								];

								$new_actions = array_values( $new_actions )[0];
								foreach ( $new_actions as $new_action ) {
									$hook = $new_action->get_hook();
									if ( isset( $expected_actions[ $hook ] ) ) {
										$expected_actions[ $hook ] --;
									} else {
										return false;
									}
								}

								return array_sum( $expected_actions ) === 0;
							},
						],
						[
							'message' => 'Check that the correct args are used.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									$args          = $new_action->get_args();
									$expected_args = WCS_Action_Scheduler_Customer_Notifications::get_action_args( $subscription );

									if ( $args !== $expected_args ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message' => 'Check that the notifications are in the correct group.',
							'type'    => 'assertTrue',
							'actual'  => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_group() !== $this->notifications_as_group ) {
										return false;
									}
								}

								return true;
							},
						],
						[
							'message'  => 'Check the subscription expiry notification date is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$end_date = new DateTime( $subscription->get_date( 'end_date' ) );
								$end_date->modify( $this->offset );

								return $end_date;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_expiration' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
						[
							'message'  => 'Check the next payment date notification is correct.',
							'expected' => function ( $subscription, $new_actions ) {
								$next_payment = new DateTime( $subscription->get_date( 'next_payment' ) );
								$next_payment->modify( $this->offset );

								return $next_payment;
							},
							'actual'   => function ( $subscription, $new_actions ) {
								$new_actions = array_values( $new_actions )[0];

								foreach ( $new_actions as $new_action ) {
									if ( $new_action->get_hook() === 'woocommerce_scheduled_subscription_customer_notification_renewal' ) {
										return $new_action->get_schedule()->get_date();
									}
								}
							},
						],
					],
				],
		];
	}

	public function test_notifications_general() {
		$data_provided = $this->notification_expectations_data_provider();
		foreach ( $data_provided as $test_name => $data ) {
			$callback   = $data['callback'];
			$params     = $data['params'];
			$assertions = $data['assertions_config'];
			$this->notifications_general_execute_test( $callback, $params, $assertions, $test_name );
		}
	}

	protected function recursive_array_diff( $array1, $array2 ) {
		$difference = [];
		foreach ( $array1 as $key => $value ) {
			if ( is_array( $value ) ) {
				if ( ! isset( $array2[ $key ] ) || ! is_array( $array2[ $key ] ) ) {
					$difference[ $key ] = $value;
				} else {
					$new_diff = $this->recursive_array_diff( $value, $array2[ $key ] );
					if ( ! empty( $new_diff ) ) {
						$difference[ $key ] = $new_diff;
					}
				}
			} elseif ( ! array_key_exists( $key, $array2 )
						|| $array2[ $key ] != $value ) { // @phpcs:ignore WordPress.PHP.StrictComparisons.LooseComparison
						// Need to use weak comparison as the instance isn't the same.
				$difference[ $key ] = $value;
			}
		}

		return $difference;
	}

	/**
	 * Hmmm
	 *
	 */
	public function notifications_general_execute_test( callable $callback, array $params, array $assertions_config, string $test_name = '' ) {
		$this->enable_notifications_globally();

		$actions_before = [];
		foreach ( $this->notification_types as $notification_type ) {
			$actions_tmp = as_get_scheduled_actions(
				[
					'hook'     => $notification_type,
					'group'    => $this->notifications_as_group,
					'per_page' => 1000,
					// not interested in cancelled actions.
					'status'   => [
						0 => ActionScheduler_Store::STATUS_COMPLETE,
						1 => ActionScheduler_Store::STATUS_PENDING,
						2 => ActionScheduler_Store::STATUS_RUNNING,
						3 => ActionScheduler_Store::STATUS_FAILED,
					],
				]
			);

			foreach ( $actions_tmp as $action ) {
				$actions_before[ $action->get_args()['subscription_id'] ][] = $action;
			}
		}

		$subscription = $callback( ...$params );

		$actions_after = [];
		foreach ( $this->notification_types as $notification_type ) {
			$actions_tmp = as_get_scheduled_actions(
				[
					'hook'     => $notification_type,
					'group'    => $this->notifications_as_group,
					'per_page' => 1000,
					// not interested in cancelled actions.
					'status'   => [
						0 => ActionScheduler_Store::STATUS_COMPLETE,
						1 => ActionScheduler_Store::STATUS_PENDING,
						2 => ActionScheduler_Store::STATUS_RUNNING,
						3 => ActionScheduler_Store::STATUS_FAILED,
					],
				]
			);

			foreach ( $actions_tmp as $action ) {
				$actions_after[ $action->get_args()['subscription_id'] ][] = $action;
			}
		}

		$new_actions = $this->recursive_array_diff( $actions_after, $actions_before );

		foreach ( $assertions_config as $assertion ) {
			// Extract assertion type, expected value, and actual value from the config
			$assertion_type = $assertion['type'] ?? 'assertEquals';

			if ( isset( $assertion['expected'] ) ) {
				if ( is_callable( $assertion['expected'] ) ) {
					$expected = $assertion['expected']( $subscription, $new_actions ); // Invoke the callable with $result as an argument
				} else {
					$expected = $assertion['expected'] ?? $subscription; // Default to using the result of the callback
				}
			}

			if ( is_callable( $assertion['actual'] ) ) {
				$actual = $assertion['actual']( $subscription, $new_actions ); // Invoke the callable with $result as an argument
			} else {
				$actual = $assertion['actual'] ?? $subscription; // Default to using the result of the callback
			}

			$msg = isset( $assertion['message'] ) ? $test_name . ':' . $assertion['message'] : $test_name;

			// Perform the assertion dynamically
			switch ( $assertion_type ) {
				case 'assertEquals':
					$this->assertEquals( $expected, $actual, $msg );
					break;
				case 'assertTrue':
					$this->assertTrue( $actual, $msg );
					break;
				case 'assertFalse':
					$this->assertFalse( $actual, $msg );
					break;
				default:
					throw Exception( 'Unknown assertion type ' . $assertion_type );
			}
		}
	}

	/**
	 * Check that notification gets updated correctly when subscription is automatically renewed.
	 *
	 * @return void
	 */
	public function test_notification_updated_when_subscription_auto_renewed() {

	}

	/**
	 * Check that notification gets updated correctly when subscription is manually renewed.
	 *
	 * @return void
	 */
	public function test_notification_updated_when_subscription_manually_renewed() {

	}

	/**
	 * Check that notification gets updated correctly when subscription is up- or downgraded.
	 *
	 * @return void
	 */
	public function test_notification_updated_when_subscription_up_downgraded() {

	}

	/**
	 * Check that free-trial -> paid subscription correctly created a notification.
	 *
	 * @return void
	 */
	public function test_notification_updated_when_subscription_converted_to_paid() {

	}

	/**
	 * Check that notification gets removed when subscription gets cancelled (or do we keep it?).
	 *
	 * @return void
	 */
	public function test_notification_removed_when_subscription_cancelled() {

	}

	/**
	 * Check that notification can be triggered manually.
	 *
	 * @return void
	 */
	public function test_manually_trigger_notification() {

	}

	public function test_auto_notification_adds_order_note() {

	}

	public function test_manual_notification_adds_order_note() {

	}

	/**
	 * Check that store manager can set notification period.
	 *
	 * @return void
	 */
	public function test_set_notification_period() {

	}

	/**
	 * Check that store manager can change notification period and notifications are updated.
	 *
	 * @return void
	 */
	public function test_change_notification_period() {

	}

	/**
	 * Check that notification gets created for all existing subscriptions.
	 *
	 * @return void
	 */
	public function test_notifications_created_for_all_existing_subscriptions() {

	}

	/**
	 * Check that developers can filter notifications.
	 *
	 * @return void
	 */
	public function test_filter_notification() {

	}

	/**
	 * Check that developers can customize email notification.
	 *
	 * @return void
	 */
	public function test_customize_email_content() {

	}

	/**
	 * Check that enabling and disabling of notifications works.
	 *
	 * @return void
	 */
	public function test_enable_disable_notifications() {

	}

	/**
	 * Check that subscription notifications are disabled on staging/non-live sites.
	 *
	 * @return void
	 */
	public function test_disable_notifications_in_staging() {

	}


}

